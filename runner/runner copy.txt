package runner

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"reflect"
	"sort"
	"strings"
	"sync"
	"time"

	"golang.org/x/time/rate"
	"gopkg.in/natefinch/lumberjack.v2"

	"tg45/datafile"
	"tg45/db"
	"tg45/logs"
	"tg45/model"
)

/*
—Ñ–æ—Ä–º–∞—Ç –ø–µ—Ä–µ–æ–¥–∏—á–Ω–æ—Å—Ç–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞ –±–∏–Ω–∞—Ä–Ω–∏–∫–∞
"23s"        // 23 —Å–µ–∫—É–Ω–¥—ã
"16m"        // 16 –º–∏–Ω—É—Ç
"1h01m01s"   // 1 —á–∞—Å 1 –º–∏–Ω—É—Ç–∞ 1 —Å–µ–∫—É–Ω–¥–∞
"90m"        // 90 –º–∏–Ω—É—Ç (= 1.5 —á–∞—Å–∞)
"3600s"      // 3600 —Å–µ–∫—É–Ω–¥ (= 1 —á–∞—Å)
"1h30m"      // 1 —á–∞—Å 30 –º–∏–Ω—É—Ç
"2h15m30s"   // 2 —á–∞—Å–∞ 15 –º–∏–Ω—É—Ç 30 —Å–µ–∫—É–Ω–¥
"500ms"      // 500 –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥
"1.5h"       // 1.5 —á–∞—Å–∞ —Å –¥–µ—Å—è—Ç–∏—á–Ω–æ–π –¥—Ä–æ–±—å—é
"45m30s"     // 45 –º–∏–Ω—É—Ç 30 —Å–µ–∫—É–Ω–¥
*/

// DataSource –æ–ø–∏—Å—ã–≤–∞–µ—Ç –æ–¥–∏–Ω –∏—Å—Ç–æ—á–Ω–∏–∫ –¥–∞–Ω–Ω—ã—Ö
type DataSource struct {
	Name           string `json:"Name"`                     // TG4, TG5, etc
	DataFileName   string `json:"DataFileName"`             // Tg4.dat, Tg5.dat
	ParserType     string `json:"ParserType"`               // tg4, tg5
	LogFileName    string `json:"LogFileName"`              // write_attempts_tg4.log
	Enabled        bool   `json:"Enabled"`                  // –≤–∫–ª—é—á–µ–Ω –ª–∏ –∏—Å—Ç–æ—á–Ω–∏–∫
	Quality        int    `json:"Quality"`                  // –∫–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö
	UpdateInterval string `json:"UpdateInterval"`           //–∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–∞—Ä—Å–∏–Ω–≥–∞ –±–∏–Ω–∞—Ä–Ω–∏–∫–∞
	StaleThreshold string `json:"StaleThreshold,omitempty"` // "5m", "70m", "2h"
}

// Config –æ–ø–∏—Å—ã–≤–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
type Config struct {
	LogMode          string       `json:"LogMode"`          // "all" –∏–ª–∏ "errors"
	ConnString       string       `json:"ConnString"`       // —Å—Ç—Ä–æ–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ MS SQL
	DataSources      []DataSource `json:"DataSources"`      // –º–∞—Å—Å–∏–≤ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö
	StartAllOnLaunch bool         `json:"StartAllOnLaunch"` // –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫
}

// SourceRunner —É–ø—Ä–∞–≤–ª—è–µ—Ç –æ–¥–Ω–∏–º –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º –¥–∞–Ω–Ω—ã—Ö
type SourceRunner struct {
	Source           DataSource
	Logger           *log.Logger
	Database         *sql.DB
	StopChan         chan struct{}
	Running          bool
	Mutex            sync.Mutex
	wg               sync.WaitGroup // ‚Üê –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≥–æ—Ä—É—Ç–∏–Ω–∞–º–∏
	updateInterval   time.Duration  // ‚Üê –∏–Ω—Ç–µ—Ä–≤–∞–ª –ø–∞—Ä—Å–∏–Ω–≥–∞
	lumberjackLogger *lumberjack.Logger

	restartCount int       // —Å—á–µ—Ç—á–∏–∫ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–æ–≤
	lastError    error     // –ø–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞
	lastRestart  time.Time // –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞
	// –ú–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
	totalProcessed int64
	totalErrors    int64
	rateLimiter    *rate.Limiter
	logFile        io.Closer
	circuitBreaker *CircuitBreaker
	// üîß –ù–û–í–´–ï –ü–û–õ–Ø –î–õ–Ø –ú–û–ù–ò–¢–û–†–ò–ù–ì–ê –§–ê–ô–õ–ê
	fileStaleThreshold time.Duration // –í—Ä–µ–º—è "—É—Å—Ç–∞—Ä–µ–≤–∞–Ω–∏—è" —Ñ–∞–π–ª–∞ (5 –º–∏–Ω—É—Ç)
	lastFileModTime    time.Time     // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞
	lastSuccessfulRead time.Time     // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —É—Å–ø–µ—à–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è
	zeroDataWrites     int64         // –°—á–µ—Ç—á–∏–∫ –∑–∞–ø–∏—Å–µ–π –Ω—É–ª–µ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
	LogMode            string
}

func (sr *SourceRunner) GetMetrics() map[string]interface{} {
	sr.Mutex.Lock()
	defer sr.Mutex.Unlock()

	timeSinceLastFile := time.Duration(0)
	if !sr.lastFileModTime.IsZero() {
		timeSinceLastFile = time.Since(sr.lastFileModTime)
	}

	return map[string]interface{}{
		"processed":        sr.totalProcessed,
		"errors":           sr.totalErrors,
		"restarts":         sr.restartCount,
		"zero_data_writes": sr.zeroDataWrites, // –°—á–µ—Ç—á–∏–∫ –Ω—É–ª–µ–≤—ã—Ö –∑–∞–ø–∏—Å–µ–π
		"data_is_fresh":    timeSinceLastFile < sr.fileStaleThreshold,
		"file_age_minutes": int(timeSinceLastFile.Minutes()),
		"last_real_data":   sr.lastSuccessfulRead, //  –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
		"last_error":       sr.lastError,
		"running":          sr.Running,
	}
}

func NewCircuitBreaker(threshold int, timeout time.Duration) *CircuitBreaker {
	return &CircuitBreaker{
		threshold: threshold,
		timeout:   timeout,
	}
}

func (cb *CircuitBreaker) CallWithContext(ctx context.Context, fn func() error) error {
	cb.mutex.Lock()

	if cb.failures >= cb.threshold {
		if time.Since(cb.lastFailTime) < cb.timeout {
			cb.mutex.Unlock()
			return fmt.Errorf("circuit breaker is open")
		}
		cb.failures = 0 // Reset –ø–æ—Å–ª–µ timeout
	}
	cb.mutex.Unlock()

	errCh := make(chan error, 1)
	go func() {
		defer func() {
			if r := recover(); r != nil {
				errCh <- fmt.Errorf("panic: %v", r)
			}
		}()
		errCh <- fn()
	}()

	select {
	case <-ctx.Done():
		return ctx.Err()
	case err := <-errCh:
		if err != nil {
			cb.mutex.Lock()
			cb.failures++
			cb.lastFailTime = time.Now()
			cb.mutex.Unlock()
			return err
		}

		cb.mutex.Lock()
		cb.failures = 0 // –£—Å–ø–µ—Ö - —Å–±—Ä–æ—Å
		cb.mutex.Unlock()
		return nil
	}
}

// NewSourceRunner —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π runner –¥–ª—è –∏—Å—Ç–æ—á–Ω–∏–∫–∞
func NewSourceRunner(source DataSource, connString string) (*SourceRunner, error) {
	maxSize := 150 // –Ω–∞–ø—Ä–∏–º–µ—Ä, –º–æ–∂–Ω–æ –≤—ã–Ω–µ—Å—Ç–∏ –≤ –∫–æ–Ω—Ñ–∏–≥

	// –°–æ–∑–¥–∞–µ–º lumberjack.Logger
	l := &lumberjack.Logger{
		Filename:   source.LogFileName,
		MaxSize:    maxSize,
		MaxBackups: 7,
		MaxAge:     30,
		Compress:   true,
	}

	// –°–æ–∑–¥–∞–µ–º –ª–æ–≥–≥–µ—Ä –Ω–∞ –æ—Å–Ω–æ–≤–µ lumberjack
	logger := log.New(l, "", log.LstdFlags|log.Lmicroseconds)

	database, err := sql.Open("sqlserver", connString)
	if err != nil {
		l.Close() // –∑–∞–∫—Ä—ã–≤–∞–µ–º lumberjack –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
		return nil, err
	}

	database.SetMaxOpenConns(10)
	database.SetMaxIdleConns(2)
	database.SetConnMaxLifetime(5 * time.Minute)
	database.SetConnMaxIdleTime(2 * time.Minute)

	if err := database.Ping(); err != nil {
		database.Close()
		l.Close()
		return nil, fmt.Errorf("–Ω–µ —É–¥–∞–µ—Ç—Å—è –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö: %w", err)
	}

	var updateInterval time.Duration
	if source.UpdateInterval != "" {
		parsed, err := time.ParseDuration(source.UpdateInterval)
		if err != nil {
			logger.Printf("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ UpdateInterval '%s': %v. –ò—Å–ø–æ–ª—å–∑—É–µ–º 15s –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é", source.UpdateInterval, err)
			updateInterval = 15 * time.Second
		} else {
			updateInterval = parsed
		}
	} else {
		updateInterval = 15 * time.Second
	}

	if updateInterval < 1*time.Second {
		logger.Printf("[%s] UpdateInterval —Å–ª–∏—à–∫–æ–º –º–∞–ª (%v), —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –º–∏–Ω–∏–º—É–º 1s", source.Name, updateInterval)
		updateInterval = 1 * time.Second
	}

	if updateInterval > 1*time.Hour {
		logger.Printf("[%s] UpdateInterval —Å–ª–∏—à–∫–æ–º –≤–µ–ª–∏–∫ (%v), —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –º–∞–∫—Å–∏–º—É–º 1h", source.Name, updateInterval)
		updateInterval = 1 * time.Hour
	}

	var staleThreshold time.Duration
	if source.StaleThreshold != "" {
		parsed, err := time.ParseDuration(source.StaleThreshold)
		if err != nil {
			logger.Printf("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ StaleThreshold '%s': %v", source.StaleThreshold, err)
		} else {
			staleThreshold = parsed
		}
	}

	if staleThreshold == 0 {
		switch source.ParserType {
		case "tg5_hour":
			staleThreshold = 70 * time.Minute
		default:
			staleThreshold = 5 * time.Minute
		}
	}

	logger.Printf("[%s] –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: %v, –ø–æ—Ä–æ–≥ —É—Å—Ç–∞—Ä–µ–≤–∞–Ω–∏—è: %v",
		source.Name, updateInterval, staleThreshold)

	return &SourceRunner{
		Source:             source,
		Logger:             logger,
		Database:           database,
		logFile:            l, // –∑–¥–µ—Å—å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–∞ l
		StopChan:           make(chan struct{}),
		Running:            false,
		updateInterval:     updateInterval,
		restartCount:       0,
		lastError:          nil,
		lastRestart:        time.Time{},
		rateLimiter:        rate.NewLimiter(rate.Limit(1), 5),
		circuitBreaker:     NewCircuitBreaker(5, 1*time.Minute),
		lastSuccessfulRead: time.Now(),
		zeroDataWrites:     0,
		fileStaleThreshold: staleThreshold,
		lumberjackLogger:   l,
	}, nil
}

func (sr *SourceRunner) LoggerInfo() string {
	if sr.lumberjackLogger == nil {
		return "lumberjack logger not initialized"
	}
	return fmt.Sprintf("Log file: %s; MaxSize: %dMB; MaxBackups: %d; MaxAge: %d days; Compress: %v",
		sr.lumberjackLogger.Filename,
		sr.lumberjackLogger.MaxSize,
		sr.lumberjackLogger.MaxBackups,
		sr.lumberjackLogger.MaxAge,
		sr.lumberjackLogger.Compress,
	)
}

type CircuitBreaker struct {
	failures     int
	threshold    int
	timeout      time.Duration
	lastFailTime time.Time
	mutex        sync.Mutex
}

// func (cb *CircuitBreaker) Call(fn func() error) error {
// 	cb.mutex.Lock()
// 	defer cb.mutex.Unlock()

// 	if cb.failures >= cb.threshold {
// 		if time.Since(cb.lastFailTime) < cb.timeout {
// 			return fmt.Errorf("circuit breaker is open")
// 		}
// 		cb.failures = 0 // reset
// 	}

// 	err := fn()
// 	if err != nil {
// 		cb.failures++
// 		cb.lastFailTime = time.Now()
// 		return err
// 	}

// 	cb.failures = 0
// 	return nil
// }

func (sr *SourceRunner) Start(logMode string) {
	sr.Logger.Printf("[%s] Logger info: %s", sr.Source.Name, sr.LoggerInfo())

	sr.Mutex.Lock()
	defer sr.Mutex.Unlock()

	if sr.Running {
		if logMode == "all" {
			sr.Logger.Printf("[%s] –£–∂–µ –∑–∞–ø—É—â–µ–Ω", sr.Source.Name)
		}
		return
	}

	sr.Logger.Printf("[%s] –°—Ç–∞—Ä—Ç –ø—Ä–æ—Ü–µ—Å—Å–∞", sr.Source.Name)
	sr.Running = true
	sr.StopChan = make(chan struct{})

	sr.wg.Add(1)
	go func() {
		defer sr.wg.Done()
		// –î–û–ë–ê–í–õ–Ø–ï–ú –ó–ê–©–ò–¢–£ –û–¢ PANIC
		defer func() {
			if r := recover(); r != nil {
				sr.Logger.Printf("[%s] –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê - –≥–æ—Ä—É—Ç–∏–Ω–∞ —É–ø–∞–ª–∞: %v", sr.Source.Name, r)
				sr.Mutex.Lock()
				sr.lastError = fmt.Errorf("panic: %v", r)
				sr.restartCount++
				sr.lastRestart = time.Now()
				sr.Running = false
				sr.Mutex.Unlock()

				// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ 30 —Å–µ–∫—É–Ω–¥ (–µ—Å–ª–∏ –Ω–µ –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç)
				if sr.restartCount <= 5 { // –º–∞–∫—Å–∏–º—É–º 5 –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–æ–≤
					go func() {
						time.Sleep(30 * time.Second)
						sr.Logger.Printf("[%s] –ü–æ–ø—ã—Ç–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ (%d/5)",
							sr.Source.Name, sr.restartCount)
						sr.Start(logMode)
					}()
				}
			} else {
				sr.Mutex.Lock()
				sr.Running = false
				sr.Mutex.Unlock()
			}

			if logMode == "all" {
				sr.Logger.Printf("[%s] –ì–æ—Ä—É—Ç–∏–Ω–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å", sr.Source.Name)
			}
		}()

		sr.runMainLoop(logMode)
	}()

	if logMode == "all" {
		sr.Logger.Printf("[%s] Start completed", sr.Source.Name)
	}
}

// checkFileHealth –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Å–≤–µ–∂–µ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª–∞
func (sr *SourceRunner) checkFileHealth() (isFresh bool, err error) {
	fileInfo, err := os.Stat(sr.Source.DataFileName)
	if err != nil {
		return false, fmt.Errorf("—Ñ–∞–π–ª –¥–∞–Ω–Ω—ã—Ö –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: %w", err)
	}

	currentModTime := fileInfo.ModTime()
	timeSinceUpdate := time.Since(currentModTime)

	// üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –£–ñ–ï –£–°–¢–ê–ù–û–í–õ–ï–ù–ù–´–ô –ü–û–†–û–ì - –ë–ï–ó –î–£–ë–õ–ò–†–û–í–ê–ù–ò–Ø
	if timeSinceUpdate > sr.fileStaleThreshold {
		sr.Logger.Printf("[%s] –î–ê–ù–ù–´–ï –£–°–¢–ê–†–ï–õ–ò: —Ñ–∞–π–ª –Ω–µ –æ–±–Ω–æ–≤–ª—è–ª—Å—è %v (–ª–∏–º–∏—Ç %v)",
			sr.Source.Name, timeSinceUpdate, sr.fileStaleThreshold)
		return false, nil
	}

	// –î–∞–Ω–Ω—ã–µ —Å–≤–µ–∂–∏–µ - –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
	sr.lastFileModTime = currentModTime
	return true, nil
}

// –í—ã–Ω–æ—Å–∏–º –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥
func (sr *SourceRunner) runMainLoop(logMode string) {
	if logMode == "all" {
		sr.Logger.Printf("[%s] –ì–æ—Ä—É—Ç–∏–Ω–∞ –∑–∞–ø—É—Å—Ç–∏–ª–∞—Å—å", sr.Source.Name)
	}

	for {
		select {
		case <-sr.StopChan:
			if logMode == "all" {
				sr.Logger.Printf("[%s] –ü—Ä–æ—Ü–µ—Å—Å –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", sr.Source.Name)
			}
			return
		default:
			// –ò–°–ü–û–õ–¨–ó–£–ï–ú RETRY LOGIC
			err := sr.processDataWithRetry(logMode)
			if err != nil {
				sr.Logger.Printf("[%s] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö: %v", sr.Source.Name, err)
				sr.Mutex.Lock()
				sr.lastError = err
				sr.Mutex.Unlock()
			} else {
				// –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–µ
				sr.Mutex.Lock()
				sr.restartCount = 0
				sr.lastError = nil
				sr.Mutex.Unlock()
			}

			select {
			case <-sr.StopChan:
				return
			case <-time.After(sr.updateInterval):
				// –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
			}
		}
	}
}

// –ù–û–í–´–ô –º–µ—Ç–æ–¥ —Å retry logic
func (sr *SourceRunner) processDataWithRetry(logMode string) error {
	if !sr.rateLimiter.Allow() {
		return fmt.Errorf("rate limit exceeded")
	}

	// üîß –ü–†–û–í–ï–†–Ø–ï–ú –°–í–ï–ñ–ï–°–¢–¨ –î–ê–ù–ù–´–•
	isFresh, err := sr.checkFileHealth()
	if err != nil {
		// –°–µ—Ä—å–µ–∑–Ω–∞—è –æ—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª—É
		sr.Logger.Printf("[%s] –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª—É: %v", sr.Source.Name, err)
		return err
	}

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()

	if !isFresh {
		// üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú –§–£–ù–ö–¶–ò–Æ –° RETRY –î–õ–Ø NULL –î–ê–ù–ù–´–•
		return sr.writeZeroDataWithRetry(ctx, logMode)
	} else {
		// üîß –î–ê–ù–ù–´–ï –°–í–ï–ñ–ò–ï - –ß–ò–¢–ê–ï–ú –ò–ó –§–ê–ô–õ–ê
		return sr.processRealDataWithRetry(ctx, logMode)
	}
}

// processRealDataWithRetry —á–∏—Ç–∞–µ—Ç –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞
func (sr *SourceRunner) processRealDataWithRetry(ctx context.Context, logMode string) error {
	maxRetries := 3
	baseDelay := 2 * time.Second

	for attempt := 0; attempt <= maxRetries; attempt++ {
		err := sr.processDataWithContext(ctx, logMode)
		if err == nil {
			// üîß –û–ë–ù–û–í–õ–Ø–ï–ú –í–†–ï–ú–Ø –£–°–ü–ï–®–ù–û–ì–û –ß–¢–ï–ù–ò–Ø –†–ï–ê–õ–¨–ù–´–• –î–ê–ù–ù–´–•
			sr.Mutex.Lock()
			sr.lastSuccessfulRead = time.Now()
			sr.totalProcessed++
			sr.Mutex.Unlock()
			return nil
		}

		if attempt == maxRetries {
			// üîß –û–ë–ù–û–í–õ–Ø–ï–ú –°–ß–ï–¢–ß–ò–ö –û–®–ò–ë–û–ö
			sr.Mutex.Lock()
			sr.totalErrors++ // ‚Üê –î–û–ë–ê–í–¨ –≠–¢–û
			sr.Mutex.Unlock()
			return fmt.Errorf("–ø—Ä–µ–≤—ã—à–µ–Ω–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ (%d): %w", maxRetries, err)
		}

		delay := baseDelay * time.Duration(1<<attempt)
		select {
		case <-sr.StopChan:
			return fmt.Errorf("–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤–æ –≤—Ä–µ–º—è retry")
		case <-ctx.Done():
			return ctx.Err()
		case <-time.After(delay):
			// continue retry
		}
	}
	return nil
}

// writeZeroData –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç NULL –∑–Ω–∞—á–µ–Ω–∏—è –≤ –ë–î —Å timestamp –∏–∑ —Ñ–∞–π–ª–∞ (–ø–µ—Ä–µ–¥–∞—á–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞)
func (sr *SourceRunner) writeZeroData(ctx context.Context, logMode string) error {
	sr.Logger.Printf("[%s] –ü–ï–†–ï–î–ê–ß–ê –û–¢–ö–õ–Æ–ß–ï–ù–ê - –ø–∏—à–µ–º NULL –∑–Ω–∞—á–µ–Ω–∏—è —Å timestamp –∏–∑ —Ñ–∞–π–ª–∞", sr.Source.Name)

	// üîß –ß–ò–¢–ê–ï–ú TIMESTAMP –ò–ó –§–ê–ô–õ–ê (–î–ê–ñ–ï –ï–°–õ–ò –û–ù –°–¢–ê–†–´–ô)
	timeStampFile, err := sr.readTimestampFromFile()
	if err != nil {
		// –ï—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –ø—Ä–æ—á–∏—Ç–∞—Ç—å timestamp - –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞
		fileInfo, statErr := os.Stat(sr.Source.DataFileName)
		if statErr != nil {
			return fmt.Errorf("–Ω–µ —É–¥–∞–µ—Ç—Å—è –ø–æ–ª—É—á–∏—Ç—å timestamp: %w", err)
		}
		timeStampFile = fileInfo.ModTime()
		sr.Logger.Printf("[%s] –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞ –∫–∞–∫ timestamp: %v", sr.Source.Name, timeStampFile)
	}

	timeStampSystem := time.Now() // –°–∏—Å—Ç–µ–º–Ω–æ–µ –≤—Ä–µ–º—è –∑–∞–ø–∏—Å–∏ –≤ –ë–î
	zeroQuality := 0              // –ö–∞—á–µ—Å—Ç–≤–æ 0 = "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"

	// üîß –ü–ò–®–ï–ú NULL –° –ü–†–ê–í–ò–õ–¨–ù–´–ú TIMESTAMP
	err = sr.writeNullFieldsToDBWithTimestamp(ctx, timeStampSystem, timeStampFile, zeroQuality, logMode)

	if err == nil {
		// üîß –£–í–ï–õ–ò–ß–ò–í–ê–ï–ú –°–ß–ï–¢–ß–ò–ö NULL –ó–ê–ü–ò–°–ï–ô
		sr.Mutex.Lock()
		sr.zeroDataWrites++
		sr.Mutex.Unlock()

		if logMode == "all" {
			sr.Logger.Printf("[%s] –ó–∞–ø–∏—Å–∞–Ω—ã NULL –∑–Ω–∞—á–µ–Ω–∏—è —Å timestamp –∏–∑ —Ñ–∞–π–ª–∞: %v", sr.Source.Name, timeStampFile)
		}
	}

	return err
}

func (sr *SourceRunner) writeZeroDataWithRetry(ctx context.Context, logMode string) error {
	maxRetries := 3
	for attempt := 0; attempt <= maxRetries; attempt++ {
		err := sr.writeZeroData(ctx, logMode)
		if err == nil || !isDeadlockError(err) {
			return err
		}
		if attempt < maxRetries {
			time.Sleep(time.Duration(50*(attempt+1)) * time.Millisecond)
		}
	}
	// üîß –ò–°–ü–†–ê–í–õ–ï–ù–û: –Ω—É–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å –æ—à–∏–±–∫—É –µ—Å–ª–∏ –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –∏—Å—á–µ—Ä–ø–∞–Ω—ã
	return fmt.Errorf("writeZeroData failed after %d attempts", maxRetries+1)
}

// isDeadlockError –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—à–∏–±–∫–∞ deadlock
func isDeadlockError(err error) bool {
	if err == nil {
		return false
	}
	errStr := strings.ToLower(err.Error())
	return strings.Contains(errStr, "was deadlocked") ||
		strings.Contains(errStr, "deadlock victim") ||
		strings.Contains(errStr, "transaction (process id")
}

// readTimestampFromFile —á–∏—Ç–∞–µ—Ç timestamp –∏–∑ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –ø–∞—Ä—Å–µ—Ä–∞
func (sr *SourceRunner) readTimestampFromFile() (time.Time, error) {
	switch sr.Source.ParserType {
	case "tg4":
		data, err := datafile.ReadData[model.Data_TG4](sr.Source.DataFileName)
		if err != nil {
			return time.Time{}, err
		}
		return time.Date(
			int(data.Fltv180Offs360),             // –≥–æ–¥
			time.Month(int(data.Fltv181Offs364)), // –º–µ—Å—è—Ü
			int(data.Fltv182Offs368),             // –¥–µ–Ω—å
			int(data.Fltv177Offs348),             // —á–∞—Å
			int(data.Fltv178Offs352),             // –º–∏–Ω—É—Ç–∞
			int(data.Fltv179Offs356),             // —Å–µ–∫—É–Ω–¥–∞
			0, time.UTC,
		), nil

	case "tg5":
		data, err := datafile.ReadData[model.Data_TG5_Minute](sr.Source.DataFileName)
		if err != nil {
			return time.Time{}, err
		}
		return time.Date(
			int(data.Fltv105Offs447),             // –≥–æ–¥
			time.Month(int(data.Fltv106Offs451)), // –º–µ—Å—è—Ü
			int(data.Fltv107Offs455),             // –¥–µ–Ω—å
			int(data.Fltv102Offs434),             // —á–∞—Å
			int(data.Fltv103Offs438),             // –º–∏–Ω—É—Ç–∞
			int(data.Fltv104Offs442),             // —Å–µ–∫—É–Ω–¥–∞
			0, time.UTC,
		), nil

	case "tg5_hour":
		data, err := datafile.ReadData[model.Data_TG5_Hour](sr.Source.DataFileName)
		if err != nil {
			return time.Time{}, err
		}
		return time.Date(
			int(data.Fltv105Offs447),             // –≥–æ–¥
			time.Month(int(data.Fltv106Offs451)), // –º–µ—Å—è—Ü
			int(data.Fltv107Offs455),             // –¥–µ–Ω—å
			int(data.Fltv102Offs434),             // —á–∞—Å
			int(data.Fltv103Offs438),             // –º–∏–Ω—É—Ç–∞
			int(data.Fltv104Offs442),             // —Å–µ–∫—É–Ω–¥–∞
			0, time.UTC,
		), nil

	default:
		return time.Time{}, fmt.Errorf("–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –ø–∞—Ä—Å–µ—Ä–∞: %s", sr.Source.ParserType)
	}
}

// writeNullFieldsToDBWithTimestamp –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç NULL –≤ –ë–î —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º timestamp
func (sr *SourceRunner) writeNullFieldsToDBWithTimestamp(ctx context.Context, timeStampSystem, timeStampFile time.Time, quality int, logMode string) error {
	// üîß –ü–û–õ–£–ß–ê–ï–ú –°–ü–ò–°–û–ö IDTAG –ò–ó –°–¢–†–£–ö–¢–£–†–´ –î–ê–ù–ù–´–•
	var idTags []string

	switch sr.Source.ParserType {
	case "tg4":
		idTags = sr.getIdTagsFromStruct(model.Data_TG4{})
	case "tg5":
		idTags = sr.getIdTagsFromStruct(model.Data_TG5_Minute{})
	case "tg5_hour":
		idTags = sr.getIdTagsFromStruct(model.Data_TG5_Hour{})
	default:
		return fmt.Errorf("–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –ø–∞—Ä—Å–µ—Ä–∞: %s", sr.Source.ParserType)
	}

	// üîß –ó–ê–ü–ò–°–´–í–ê–ï–ú NULL –° –ü–†–ê–í–ò–õ–¨–ù–´–ú TIMESTAMP
	return sr.saveNullDataToDB(ctx, idTags, timeStampSystem, timeStampFile, quality, logMode)
}

// getIdTagsFromStruct –∏–∑–≤–ª–µ–∫–∞–µ—Ç –≤—Å–µ IdTag –∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
func (sr *SourceRunner) getIdTagsFromStruct(dataStruct interface{}) []string {
	var idTags []string
	t := reflect.TypeOf(dataStruct)

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		if field.Type.Kind() == reflect.Float32 {
			idTag := field.Tag.Get("idTag")
			if idTag != "" {
				idTags = append(idTags, idTag)
			}
		}
	}

	// –°–æ—Ä—Ç–∏—Ä—É–µ–º –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è deadlock
	sort.Strings(idTags)
	return idTags
}

// saveNullDataToDB –≤—ã–ø–æ–ª–Ω—è–µ—Ç UPSERT –¥–ª—è –∫–∞–∂–¥–æ–≥–æ IdTag —Å NULL –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
func (sr *SourceRunner) saveNullDataToDB(ctx context.Context, idTags []string, timeStampSystem, timeStampFile time.Time, quality int, logMode string) error {
	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∞—Ä—Ö–∏–≤–Ω—É—é —Ç–∞–±–ª–∏—Ü—É
	var dataTable string
	switch sr.Source.ParserType {
	case "tg4":
		dataTable = "ByMinutes"
	case "tg5":
		dataTable = "ByMinutes"
	case "tg5_hour":
		dataTable = "ByHours"
	default:
		dataTable = "ByMinutes"
	}

	tx, err := sr.Database.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: %w", err)
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	successCount := 0
	for _, idTag := range idTags {
		//  –ò–°–ü–û–õ–¨–ó–£–ï–ú sql.NullFloat64{Valid: false} –î–õ–Ø NULL
		nullValue := sql.NullFloat64{Valid: false} // NULL value

		//  UPSERT –¥–ª—è –∞—Ä—Ö–∏–≤–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã —Å NULL –∑–Ω–∞—á–µ–Ω–∏–µ–º
		archiveQuery := fmt.Sprintf(`
MERGE %s AS target
USING (VALUES (@p1, @p2)) AS source (IdTag, TimeStamp)
ON target.IdTag = source.IdTag AND target.TimeStamp = source.TimeStamp
WHEN NOT MATCHED THEN 
    INSERT (IdTag, TimeStamp, Value, Quality, timeStampSystem)
    VALUES (@p1, @p2, @p3, @p4, @p5);`, dataTable)

		_, err = tx.ExecContext(ctx, archiveQuery,
			idTag, timeStampFile, nullValue, quality, timeStampSystem)
		if err != nil {
			logs.LogWriteAttempt(sr.Logger, idTag, fmt.Sprintf("%s_NULL_UPSERT_FAIL", dataTable), err, logMode)
			// –ù–ï —Ä–æ–Ω—è–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –∞—Ä—Ö–∏–≤–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã
		} else {
			logs.LogWriteAttempt(sr.Logger, idTag, fmt.Sprintf("%s_NULL_UPSERT_SUCCESS", dataTable), nil, logMode)
		}

		successCount++
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("–æ—à–∏–±–∫–∞ –∫–æ–º–º–∏—Ç–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: %w", err)
	}

	if logMode == "all" {
		sr.Logger.Printf("[%s] –ó–∞–ø–∏—Å–∞–Ω–æ %d NULL –∑–Ω–∞—á–µ–Ω–∏–π –≤ %s", sr.Source.Name, successCount, dataTable)
	}

	return nil
}

// processData –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞ –ø–æ —Ç–∏–ø—É –ø–∞—Ä—Å–µ—Ä–∞
func (sr *SourceRunner) processDataWithContext(ctx context.Context, logMode string) error {
	switch sr.Source.ParserType {
	case "tg4":
		return sr.processTG4Data(ctx, logMode)
	case "tg5":
		return sr.processTG5Data(ctx, logMode)
	case "tg5_hour":
		return sr.processTG5HourData(ctx, logMode)
	default:
		return fmt.Errorf("–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –ø–∞—Ä—Å–µ—Ä–∞: %s", sr.Source.ParserType)
	}
}

// Stop –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–∞–Ω–Ω—ã—Ö
func (sr *SourceRunner) Stop() {
	sr.Mutex.Lock()
	if !sr.Running {
		sr.Mutex.Unlock()
		return
	}

	sr.Logger.Printf("[%s] –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞", sr.Source.Name)
	close(sr.StopChan) // ‚Üê –∑–∞–∫—Ä—ã–≤–∞–µ–º –∫–∞–Ω–∞–ª
	sr.Mutex.Unlock()  // ‚Üê –í–ê–ñ–ù–û: –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º –º—å—é—Ç–µ–∫—Å –î–û Wait!

	sr.wg.Wait() // ‚Üê –∂–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–æ—Ä—É—Ç–∏–Ω—ã
	sr.Logger.Printf("[%s] –ü—Ä–æ—Ü–µ—Å—Å –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", sr.Source.Name)
}

// IsRunning –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç—É—Å —Ä–∞–±–æ—Ç—ã
func (sr *SourceRunner) IsRunning() bool {
	sr.Mutex.Lock()
	defer sr.Mutex.Unlock()
	return sr.Running
}

// processTG4Data –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ—Ç TG4 —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º generic ReadData
func (sr *SourceRunner) processTG4Data(ctx context.Context, logMode string) error {
	data, err := datafile.ReadData[model.Data_TG4](sr.Source.DataFileName)
	if err != nil {
		return err
	}

	timeStampSystem := time.Now()
	timeStampFile := time.Date(
		int(data.Fltv180Offs360),
		time.Month(int(data.Fltv181Offs364)),
		int(data.Fltv182Offs368),
		int(data.Fltv177Offs348),
		int(data.Fltv178Offs352),
		int(data.Fltv179Offs356),
		0, time.UTC,
	)

	// üîß –ò–°–ü–û–õ–¨–ó–£–ï–ú CONTEXT –≤–µ—Ä—Å–∏—é
	return db.SaveCurrentValuesContext(ctx, sr.Database, data, timeStampSystem, timeStampFile, sr.Source.Quality, sr.Logger, logMode)
}

// –ê–ù–ê–õ–û–ì–ò–ß–ù–û –¥–ª—è processTG5Data
func (sr *SourceRunner) processTG5Data(ctx context.Context, logMode string) error {
	data, err := datafile.ReadData[model.Data_TG5_Minute](sr.Source.DataFileName)
	if err != nil {
		return err
	}

	timeStampSystem := time.Now()
	timeStampFile := time.Date(
		int(data.Fltv105Offs447),
		time.Month(int(data.Fltv106Offs451)),
		int(data.Fltv107Offs455),
		int(data.Fltv102Offs434),
		int(data.Fltv103Offs438),
		int(data.Fltv104Offs442),
		0, time.UTC,
	)

	return db.SaveCurrentValuesContext(ctx, sr.Database, data, timeStampSystem, timeStampFile, sr.Source.Quality, sr.Logger, logMode)
}

// –ù–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è —á–∞—Å–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö TG5
// –ê–ù–ê–õ–û–ì–ò–ß–ù–û –¥–ª—è processTG5HourData
func (sr *SourceRunner) processTG5HourData(ctx context.Context, logMode string) error {
	data, err := datafile.ReadData[model.Data_TG5_Hour](sr.Source.DataFileName)
	if err != nil {
		return err
	}

	timeStampSystem := time.Now()
	timeStampFile := time.Date(
		int(data.Fltv105Offs447),
		time.Month(int(data.Fltv106Offs451)),
		int(data.Fltv107Offs455),
		int(data.Fltv102Offs434),
		int(data.Fltv103Offs438),
		int(data.Fltv104Offs442),
		0, time.UTC,
	)

	return db.SaveCurrentValuesContext(ctx, sr.Database, data, timeStampSystem, timeStampFile, sr.Source.Quality, sr.Logger, logMode)
}

// Close –∑–∞–∫—Ä—ã–≤–∞–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
func (sr *SourceRunner) Close() error {
	sr.Stop()

	var errs []error

	if sr.logFile != nil {
		if err := sr.logFile.Close(); err != nil {
			errs = append(errs, fmt.Errorf("log file close: %w", err))
		}
	}

	if err := sr.Database.Close(); err != nil {
		errs = append(errs, fmt.Errorf("database close: %w", err))
	}

	if len(errs) > 0 {
		return fmt.Errorf("close errors: %v", errs)
	}
	return nil
}

// LoadConfig —á–∏—Ç–∞–µ—Ç –∏ –ø–∞—Ä—Å–∏—Ç JSON –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ñ–∞–π–ª –ø–æ —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –ø—É—Ç–∏
func LoadConfig(filename string) (Config, error) {
	var cfg Config
	f, err := os.Open(filename)
	if err != nil {
		return cfg, err
	}
	defer f.Close()
	decoder := json.NewDecoder(f)
	err = decoder.Decode(&cfg)
	return cfg, err
}
